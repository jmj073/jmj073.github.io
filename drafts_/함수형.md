+ functor
  + Haskell Functor 의미
+ 배열
  + 함수형 프로그래밍 배열
+ point-free
+ 프로그래밍 언어 패러다임
+ lazy evaluation
+ ML 계열 vs 하스켈 계열
+ 순수 함수
+ 참조 투명성
+ 불변성
+ 고차 함수
+ 1급 함수
+ 함수 합성
+ 부작용 제어
+ 패턴 매칭 ADT
+ 강력한 정적 타입 + 타입 추론
+ 제어 흐름의 추상화
+ expression-oriented

---

안녕하십니까. 이 글에서 일명 "함수형 프로그래밍"에 대하여 말해보려고 합니다.

요즘 Haskell이라는 프로그래밍 언어를 배우고 있습니다. Haskell을 많이들 "함수형 프로그래밍 언어"라고 부릅니다. Haskell을 어느샌가 monad까지 공부했지만 "그래서 함수형 프로그래밍이 뭐지?"라는 질문에 답을 제대로 내리지 못하고 있었기 때문에, 이 글을 작성하면서 정리해 보려고 합니다.

# 패러다임

많이들 객체지향 프로그래밍, 절차적 프로그래밍 등에 대해 들어보셨을 겁니다. 이런 것들을 일명 "프로그래밍 패러다임"이라고 합니다. 그렇다면 함수형 프로그래밍도 프로그래밍 패러다임인걸까요? 그 전에 프로그래밍 패러다임이란게 뭘까요?

> 프로그램을 어떻게 사고하고, 어떻게 구조화하며, 무엇을 핵심 추상화로 삼을 것인가에 대한 관점

프로그램을 뭐라고 생각하십니까? 프로그램은 일종의 시스템이라고 생각할 수 있습니다. 즉, 어떤 요소들로 구성되어 있으며, 그 요소들이 일정한 규칙에 따라 상호작용하며 동작하는 대상입니다.

시스템 구축의 핵심에는 세가지가 있습니다. **기본 요소**(primitive elements), 그 요소들을 엮어 만든 **복합 물체**(compound objects), 그리고 복합 물체를 다시 하나의 단위로 다루기 위한 **추상화**(abstraction)입니다.[^1]

프로그래밍 패러다임은 프로그램을 어떻게 구축할 것인가에 대한 관점으로 볼 수 있습니다. 이러한 관점은 단순한 해석의 차이로 끝나지 않으며, 어떤 관점을 채택하는 순간 자연스럽게 허용되는 사고방식과 구조가 생기고, 반대로 어색해지거나 배제되는 사고방식과 구조가 생깁니다.

예를 들어서, 객체지향이란, 프로그램을 "상태와 행위를 함께 가진 객체들의 협력"으로 사고하고 구조화하는 패러다임입니다. 여기서 기본 요소는 객체가 될 수 있으며, 객체 간의 관계와 협력을 통해 객체들을 엮을 수 있습니다. 또한 역할과 계약을 통해 추상화가 이루어 집니다.

설명이 두루뭉실해진 것 같은데, 이 글은 객체지향에 관한 글이 아니기 때문에, 구체적인 예시는 함수형 프로그래밍에 대해서 들어보겠습니다.

일단 함수형 프로그래밍을 한마디로 정의해 보고, 그것을 풀어나가 보겠습니다.

> 함수형 프로그래밍이란, 프로그램을 '값의 변환을 수행하는 순수 함수들의 조합'으로 사고하고 구조화하는 패러다임

여기서 기본 요소는 "함수"이며, 다른 함수를 불러씀으로써 함수들을 엮고, 값에 이름을 붙여 추상화를 합니다. 함수들의 조합 또한 함수이며, 따라서 프로그램도 하나의 함수입니다.

# 함수

함수형 프로그래밍에서의 함수는 그저 명령들을 묶어놓은 단위로 취급되지 않으며, 값을 받아 다른 것으로 변환하는 계산 단위로 취급됩니다. 즉, 함수 호출은 실행이 아니라 하나의 표현식입니다. 표현식은 평가(evaluate)하면 값이 나오는 것입니다. 따라서 함수 호출을 값으로 치환할 수 있고, 값으로 치환해도 그 의미가 보존되어야 합니다.

예를 들어 봅시다.

```javascript
function foo(x) {
	return x + 1;
}
```

위의 코드에서 `foo(2)`는 `3`으로 치환될 수 있으며, 그 의미는 보존되어야 한다는 것입니다. 여기서 나오는 것이 바로 참조 투명성과 순수함수입니다.

**참조 투명성**이란 앞에서 언급했듯이 표현식을 값으로 치환할 수 있고, 값으로 치환해도 그 의미가 보존되어야 한다는 것입니다. 따라서 참조 투명한 함수를 평가하게 되면 같은 인자에 대해 항상 동일한 값을 반환해야 합니다.

**순수 함수**는 참조 투명하며, 부작용(side-effect)이 없는 함수를 말합니다. 부작용이란, 어떤 계산이 그 결과 값 외에 프로그램의 관측 가능한 상태를 변화시키는 것을 말합니다.

부작용이 있으면, 치환이 의미를 보존하지 않습니다. 또한 모든 부작용은 참조 투명성을 깨뜨리지만, 모든 참조 투명성 위반이 부작용인 것은 아닙니다. 예를 들어 난수 생성이 그렇습니다.

## 순수 함수와 특징

이제 순수 함수의 의미에서 딸려오는 특징을 말해보겠습니다.

### 최적화

최적화 수준은 일반적으로 얼마나 알고있는가와 관련이 있습니다. 순수 함수는 같은 인자에 대해 같은 결과를 낸다는 것을 알 수 있으므로, 해당 정보를 이용하여 최적화를 수행할 수 있을 것입니다. 대표적인 예로는 메모이제이션이 있습니다. 메모이제이션은 계산의 결과를 기록해두어, 같은 계산을 여러번 수행하지 않는 최적화 방법입니다.

### 재진입

순수함수는 재진입 가능합니다. 재진입 가능한 함수는 실행 도중에 중단되고, 동일한 해당 함수가 호출되더라도, 각 호출이 서로의 실행 상태를 침범하지 않고 올바르게 동작하는 함수를 말합니다.

재진입과 함께 자주 언급되는 계념인 thread-safe가 있는데, thread-safe는 여러 thread가 해당 함수를 동시해 호출해도 올바르게 동작하는 것을 말합니다. 하지만 모든 재진입 가능한 함수는 thread-safe하지만, 모든 thread-safe함수가 재진입 가능한 것은 아닙니다. 대표적인 예로는 데드락이 있습니다. 예를 들어, mutex를 사용하는 함수 f가 있고, 임계 영역안에서 함수 f가 다시 호출된다고 생각해 봅시다. 그러면 해당 함수를 실행하는 thread는 데드락에 빠지게 됩니다.

순수 함수의 재진입성이 함수형 프로그래밍과 동시성, 병렬 실행과의 궁합에 어느정도 기여를 하고있지 않나 생각합니다.

### 예측 가능성

순수 함수는 함수의 시그니처를 보고 함수가 무엇을 하는 함수인지 예측하는 것을 수월하게 해줍니다. 순수 함수는 결과 값에만 영향을 주고 그 이외의 부작용은 없기 때문에 인자와 반환 값의 타입만으로도 많은 것을 알 수 있습니다.

예를 들어 아래 함수들에서 함수 `foo`는 `int` 리스트를 받아 그 안에서 원소 하나를 뽑아 반환하는 함수일 것이라고 쉽게 예측할 수 있습니다. 그에반해 함수 `bar`는 무엇을 하는 함수일지 쉽게 예측하기 힘듭니다. 예를들어 `print`같은 함수일 수도 있고, `removeFile` 같은 함수일 수도 있을 것입니다.

```C
func foo(a: [int]) -> int
func bar(a: string) -> void
```

### 순서에  비의존적

순수 함수는 인자에만 의존하기 때문에 호출 순서에 의존적이지 않습니다. 이는 실행 순서가 비결정적인 동시성 프로그래밍과 궁합이 좋다고 할 수 있습니다.

### 치환 가능성과 대수

순수 함수는 의미를 보존하며 치환 가능하며, 이는 대수의 기반이 됩니다. 여기서 말하는 대수란 연산과 법칙을 등식으로 서술할 수 있는 것을 의미합니다. 여기서 말하는 대수란 algebraic structure를 의미합니다.

algebraic structure는 다음 세가지로 정의됩니다.

+ 집합(carrier/type)
+ 연산(operations)
+ 법칙(laws)

즉, "어떤 대상 위에, 특정 연산들이 정의되어 있고, 그 연산들이 반드시 만족해야 하는 규칙이 있다"는 것입니다.

예를 들어 Haskell에는 `Monoid`라는 typeclass(Java의 인터페이스라고 생각하면 됨. Rust로 보면 type trait)가 있습니다. 이 `Monoid`에는 `mappend`라는 연산과, `mempty`라는 항등원이 정의되어 있으며, 이 연산은 결합법칙과 항등원 법칙을 만족해야 합니다.

#### ADT(Algebraic Data Type)

ADT는 다음 아이디어에서 출발합니다.

> 데이터 타입을 몇 가지 생성 규칙(생성자)의 조합으로 정의하자.

이때 algebraic이라는 말은 타입이 합(sum)과 곱(product) 연산으로 구성된다는 뜻입니다.

sum type은 이것 또는 저것 중 하나를 나타냅니다. 예는 아래와 같습니다. `Bool`은 타입 이름이며 `True`와 `False`는 생성자의 이름입니다.

```haskell
data Bool = True | False
```

아래는 또 다른 예시입니다. `Circle`은 필드를 `Float` 하나만 가지며, `Rect`는 필드를 `Float` 두개를 가집니다. 여기서 `Rect`는 이것과 저것을 동시에 가집니다. 즉, product type입니다. `Float * Float` 가능한 값의 개수는 "`Float` 경우의 수 * `Float` 경우의 수"입니다.

```haskell
data Shape
  = Circle Float
  | Rect Float Float
```

대수적 데이터 타입(ADT)를 왜 "대수적"이라고 할까요. ADT는 수학적 대수처럼 계산할 수 있기 때문입니다.

예를 들어 다음을 봅시다. 다른 언어에서도 흔히 볼 수 있는 일명 "optional"을 Haskell 스타일로 나타낸 것입니다.

```haskell
data Maybe a = Nothing | Just a
```

위의 것을 대수적으로 쓰면 아래와 같습니다.

```
Maybe a = 1 + a
```

+ Nothing -> 1
+ Just a -> a

다음은 리스트의 예시입니다.

```haskell
data List a = Nil | Cons a (List a)
```

```
List a = 1 + a * List a
```

ADT는 대수식처럼 취급할 수 있기 때문에 다음과 같은 특징들이 생깁니다.

+ 경우의 수를 계산할 수 있다. 타입이 허용하는 값의 공간을 수학적으로 다룰 수 있다는 의미입니다. "이 타입으로 표현 가능한 상태가 무엇인지"를 정확히 열거 가능합니다.

+ 함수의 의미를 구조적으로 강제할 수 있다. 타입이 ADT면, 그 타입을 입력으로 받는 함수는 그 ADT를 분해하는 함수가 된다. 즉, `Maybe`를 예시로 들면, `Nothing` 처리와 `Just` 처리, 이 두가지를 제공해야 한다는 것입니다. 즉, 함수의 정의역이 타입으로 인해 드러나게 됩니다.

+ 리팩터링이 국소적이고 기계적으로 된다. 예를들어서 ADT에 새로운 항(즉, `|`로 구분된 새로운 생성자)를 추가하면 해당 타입을 사용하는 모든 함수는 정확히 "새로운 항" 만큼의 오류를 내게 됩니다.

+ "불가능한 상태"를 타입으로 제거할 수 있다. 예를 들어서 아래와 같은 타입에서는 "로그인이 안 됐는데 user 정보가 있는 상태", "로그인 됐는데 user 정보가 없는 상태" 같은 것이 불가능합니다.

  ```haskell
  data LoginState = Loggedout | LoggedIn User
  ```

# 더 나아가서

아직 언급 못한 것들이 많지만 이는 후속편에서 다뤄보겠습니다. 글 하나에 다 넣으려니까 솔직히 글 쓰기가 매우 귀찮다는 것을 느꼈습니다. 참고로 현재 "연재 칼럼"에서 continuation에 대해 연재중인데 이것도 많은 관심 부탁드립니다. 긴 글 읽어주셔서 감사합니다.

참고로 아직 다루지 않은 것들을 몇개 나열해 보자면 다음과 같은 것들이 있습니다.

+ pattern matching
+ 선언, point-free style
+ lazy evaluation
+ 정적 타입 + 타입 추론(type inference)
+ functor, applicative functor, monad
+ 1급 함수

---

[^1]: SICP라는 책에서 인용했습니다. 프로그래밍에 발을 들였다면 SICP를 한번쯤을 읽어보시는 것을 추천드립니다.