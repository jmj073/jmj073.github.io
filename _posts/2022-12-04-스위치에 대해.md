---
layout: post
title:  "스위치에 대해"
date:   2022-12-04 17:16:22 +0900
categories: embedded electric
typora-root-url: ./..
on_hold: true
use_math: true
---

{% comment %}
[toc]
{% endcomment %}

블로그 첫글로 무엇을 적을 지 고민하다가, 간단한(?) 것 부터 적자는 생각에서 스위치에대한 글을 써보게 되었다.   

---

# 스위치란?

[위키피디아](https://en.wikipedia.org/wiki/Switch)에 의하면 스위치는 

> 전기 회로 의 **전도 경로를 분리하거나 연결**하여 전류 를 차단 하거나 한 전도체에서 다른 전도체로 전환할 수 있는 전기 부품   

이다. 이 글에서는 **전도 경로를 분리하거나 연결**에 초점을 맞춰 전개해 나갈 생각이다. 따라서 기본적으로 스위치는 **2가지 단위 상태**를 가진다고 할 수 있겠다. **끊어져** 있거나, **연결되어** 있거나. 각각 **단락회로**<sup>short circuit</sup>와 **개방 회로**<sup>open circuit</sup>로 볼 수 있다.

+ **단락 회로**: 회로의 두 [노드](https://en.wikipedia.org/wiki/Node_(circuits))가 저항값이 0[Ω]인 저항으로 연결되어 있을 때 단락 회로라고 부름.
  + 저항값이 0[Ω]인 저항.
  + 전압값이 0[V]인 전압전원.

+ **개방 회로**: 회로의 두 노드가 연결되어 있지 않을 때 개방회로라고 부름.
  + 저항값이 ∞[Ω]인 저항.
  + 전류값이 0[A]인 전류전원.


![단락회로와 개방회로](/assets/스위치에 대해/단락회로&개방회로.png)

---

# 스위치는 가변저항이다

여기서 말하는 [가변저항](https://ko.wikipedia.org/wiki/%EA%B0%80%EB%B3%80%EC%A0%80%ED%95%AD)이란

> 저항값을 임의로 바꿀 수 있는 소자

이다. 스위치는 2가지상태, 즉 저항값이 0[Ω]일 때(단락)와 ∞[Ω]일 때(개방)를 가지므로 가변저항이라고 생각할 수 있다. ~~이세상의 모든 회로는 이어져 있다. 다만 저항값이 매우 클뿐.~~

---

# 풀업 풀다운

스위치를 저항으로 생각한다면 풀업과 풀다운 회로를 간단한 저항 분배 회로로 생각할 수 있다. ~~사실 별로 간단하지 않은듯 하다. 차라리 전압원이나 전류원으로 생각하는 것이 해석이 훨씬 쉽다.~~

<img src="/assets/스위치에 대해/전압 분배 회로.png" alt="풀-업" style="zoom: 25%;" />

## 무한대의 저항?

**무한**의 값을 가지는 저항을 사용하여 전압 분배를 계산하기 위해서는 무한에 대한 연산의 정의가 필요해 보인다. 따라서 무한의 저항에 어떤 연산이 정의될 수 있을지 찾아봤지만 아쉽게도 찾지 못했다. **만약에 아는것이 있다면 아래에 댓글을 남겨주기 바랍니다**. 

{% comment %}

아래는 그저 직관적으로 적어본 것이다.

1. 무한의 값을 가지는 저항은 또한 전류값이 0[A]인 전류원이다.

   $$
   \frac{V}{I} = R = \frac{V}{0} = \infty
   $$

   $$
   \frac{V}{R} = I = \frac{V}{\infty} = 0
   $$

2. (1)에서 $$V$$는 임의의 실수 값이다. 따라서 직관적으로 생각한다면 아래 식은 정의되지 않는다.
   $$
   0 \times \infty
   $$

   $$
   \infty \times 0
   $$

{% endcomment %}

## 전류원과 전압원

풀업 회로에서 전류원과 전압원을 이용하여 $$V_o$$를 계산하여 보자.

<img src="/assets/스위치에 대해/전류원&전압원.png" alt="전류원&전압원" style="zoom:25%;" />

+ **단락(전압원)**:   
  $$V_a = V_o - 0$$   
  $$V_o = 0$$
+ **개방(전류원)**:   
  $$I_a = \frac{V_i - V_o}{R_1}$$   
  $$0 = \frac{V_i - V_o}{R_1}$$   
  $$V_o = V_i$$

## 저항값 정하는법

> 여기서 말하는 저항값의 저항은 '가변저항'이 아니라, 풀업이나 풀다운에 사용되는 저항을 말한다.

풀업이나 풀다운 회로에서 '가변저항'의 값이 0이 된다면, 전류가 흐를 것이다. 이 전류를 source하는 장치나 sink하는 장치에 최대 전류값이 정해져 있을 수 있으므로, 이 전류값을 넘지 않도록 저항값을 잘 조정하도록 하자.

$$
\begin{aligned}
R \geq \frac{V_i}{I_{max}}
\end{aligned}
$$

+ $$R$$: 저항값
+ $$V_i$$: logic high의 전압값[V]
+ $$I_{max}$$: 최대로 source 또는 sink할 수 있는 전류값[A]

또한 저항에서 전력이 소모되며, 전력 소모는 저항값이 클수록 줄어들게 된다. 그렇다면 저항값은 무조건 큰것이 좋을 것일까? 이에대한 글은 아직 찾지 못하였으므로 일단 보류이다.

---

# 채터(chatter)

[contact bounce](https://en.wikipedia.org/wiki/Switch#Contact_bounce)라고도 한다. 기계적 스위치및 릴레이의 일반적인 문제이다. 스위치와 릴레이는 일반적으로 탄력있는 금속으로 만들어 지기 때문에 접점이 부딪히면 탄성에 의해 상태가 안정되기 전까지 스위치의 상태(이어져 있거나 끊어져 있거나) 불안정하게 계속 바뀐다.

![bouncy_switch](https://upload.wikimedia.org/wikipedia/commons/a/ac/Bouncy_Switch.png)

따라서 스위치를 사용하여 입력을 받는 장치가 스위치가 여러번 눌린 것으로 인식하는 문제가 생길 수 있다.

채터 현상이 발생하는 시간의 길이를 **채터링 시간**이라 부르겠다.



## 디바운싱(debouncing)

입력을 받는 장치가 chatter의 영향을 받지 않게 하는 것을 디바운싱이라고 한다. 

디바운싱 방식을 선택할때 고려할 사항은 다음과 같은 것들이 있다.
+ **[latency](https://ko.wikipedia.org/wiki/%EB%A0%88%EC%9D%B4%ED%84%B4%EC%8B%9C)**: 작은 것이 좋다. 하지만 디바운싱과 latency를 줄이는 것은 배타적인 관계를 가지고 있다. 따라서 디바운싱 효과를 해치지 않으면서도 latency를 줄일 수 있는 방법이 좋은 방법일 것이다.
+ **[BOM](https://ko.wikipedia.org/wiki/%EC%9E%90%EC%9E%AC_%EB%AA%85%EC%84%B8%EC%84%9C)**: latency는 작은것이 좋겠지만, latency보다 BOM이 중요할 때도 있을 것이다.
+ 부피, 무게, 전력 소모, 등등...

디바운싱은 크게 2가지 방법으로 나뉠 수 있다.

+ **하드웨어 디바운싱**: 하드웨어를 통한 디바운싱. 소프트웨어 사용 안함
  + **장점**:
    + 소프트웨어 디바운싱에 비해 비교적 간단한 편.
  + **단점**:
    + BOM(Bill Of Material)에 부품이 하나 늘수도.
    + 제품의 무게와 부피가 늘어날 수도?
+ **소프트웨어 디바운싱**: 스위치를 통한 입력을 받는 장치가 소프트웨어를 사용한다면, 소프트웨어에 디바운싱을 위한 코드를 삽입할 수 있다. 또한 디바운싱을 위한 부품이 따로 필요 없다.
  + **장점**:
    + 부품에 쓸 돈을 아낄 수 있다. 
    + 제품의 무게와 부피를 줄일 수 있다.
  + **단점**:
    + 구현이 복잡해 질 수 있다.
    + 프로세서 오버헤드를 낳을 수 있다.

### 하드웨어 디바운싱

아래 나와있는 방법들 외에도 여러분이 사용하고 있는 칩에 디바운싱을 위한 기능이 들어가있을 수도 있다. 예를 들어 DLPF(Digital Low Pass Filter)라거나.

#### 커패시터는 가변저항이다

제목만 봐도 알 수 있듯이 [커패시터](https://ko.wikipedia.org/wiki/%EC%B6%95%EC%A0%84%EA%B8%B0)를 사용한 방법이다. 다음 회로를 보자.

<img src="/assets/스위치에 대해/커패시터 회로.png" alt="커패시터 회로" style="zoom: 25%;" />

커패시터에는 정전용량<sup>capacity</sup>이라는 것이 있다. 단위는 $$[F]$$(farad)이며, 기호는 $$C$$이다.  

$$
\begin{aligned}
C = \frac{Q}{V}
\end{aligned}
$$

+ $$Q$$: 전하량
+ $$V$$: 커패시터에 걸리는 전압.

위의 회로에서 커패시터 $$C_1$$의 초기 전하량이 0이라고 하자. 따라서 $$V = \frac{Q}{C}$$에 의해 $$V_c$$는 0이된다. 따라서 커패시터에는 $$\frac{V_i - V_c}{R_1}$$만큼의 전류가 흐르게 된다. 만약 2초동안 3[A]의 전류($$Q = I \times T$$)가 흐르게 된다면 $$V_c$$는 $$\frac{6}{C}$$가 된다. 따라서 커패시터에 흐르는 전류 $$\frac{V_i - V_c}{R_1}$$가 더 작아지게 되고, 그것이 반복되어 $$V_c = V_i$$가 되면 전류가 흐르지 않게 되며 $$V_c$$는 $$V_i$$로 유지된다.

아래의 그래프는 $$V_i = 5$$일 때의 그래프이다.

<img src="/assets/스위치에 대해/커패시터 그래프.png" alt="커패시터 그래프" style="zoom: 67%;" />



커패시터에 걸리는 전압이 커지는 것이 마치 저항이 커지는 것이라고 생각해 본다면, 커패시터 또한 가변저항처럼 볼 수 있다. 

아래 회로를 보자. '가변저항' 2개를 병렬 연결해놓았다.

<img src="/assets/스위치에 대해/병렬 연결.png" alt="병렬 연결" style="zoom:25%;" />

스위치를 닫으면 바로 $$V_o = 0$$이 되겠지만, 스위치를 열때는 커패시터에 의해 $$V_o$$는 천천히 변하게 된다. 

아래 그래프를 보자. `capacitor`는 스위치와 커패시터를 병렬연결 했을 때이고, `switch`는 스위치만 있을 때이다. 커패시터가 있어도 대략 1.3정도까지 $$V_o$$가 커지는 것을 볼 수 있는데, 저것은 보통 [슈미트 트리거](https://en.wikipedia.org/wiki/Schmitt_trigger)<sup>schimitt trigger</sup>로 거르게 된다.

<img src="/assets/스위치에 대해/cap&btn graph.png" alt="cap&btn graph" style="zoom:67%;" />

### 소프트웨어 디바운싱

+ **polling**:
  + 일정 주기마다 검사하는 방식. 검사 주기는 채터링 시간보다 길어야 한다.
  + 검사는 계속 하면서, 입력이 바뀌면 일정 시간동안 입력을 유지한다. 유지하는 시간은 채터링 시간보다 길어야 한다.
+ **interrupt**:
  + 

---

# 해결할 문제

+ ∞[Ω]값을 가지는 저항의 연산 정의
+ 풀업 풀다운 회로의 저항값 정하는 방법

---

# 참조

+ [트랜지스터는 가변저항이다](https://unininu.tistory.com/21)
+ [확장된 실수](https://ko.wikipedia.org/wiki/%ED%99%95%EC%9E%A5%EB%90%9C_%EC%8B%A4%EC%88%98)
+ [contact bounce 사진](https://en.wikipedia.org/wiki/Switch#Contact_bounce)
